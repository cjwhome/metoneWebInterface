<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Met One 3315 – WebSerial Interface</title>

  <!-- Charts for the Graphs tab -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{--bg:#0b1020;--card:#121a33;--muted:#9fb0d0;--fg:#e7efff;--acc:#66d0ff;--ok:#32d296;--warn:#ffdd57;--bad:#ff6b6b;--btn:#1b2547;--line:#223055}
    *{box-sizing:border-box}
    body{margin:0;padding:24px;background:var(--bg);color:var(--fg);font:14px/1.4 Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    h1{margin:0 0 16px 0;font-size:20px}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.25);flex:1}
    .kv{background:#0e1630;padding:8px 10px;border-radius:10px}
    .kv b{display:block;font-size:12px;color:var(--muted)}
    .kv span{font-size:14px}
    button{background:var(--btn);color:var(--fg);border:1px solid #273160;border-radius:10px;padding:10px 14px;cursor:pointer}
    button.primary{background:var(--acc);color:#06121e;border-color:transparent;font-weight:700}
    button.ghost{background:transparent}
    button:disabled{opacity:.5;cursor:not-allowed}
    #terminal{height:260px;overflow:auto;background:#0a1127;border-radius:10px;padding:10px;font-family:ui-monospace,Consolas,monospace;font-size:12px;white-space:pre-wrap;border:1px solid var(--line)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0e1630;border:1px solid #21305d}
    .status-dot{width:8px;height:8px;border-radius:999px;background:var(--warn)}
    .status-dot.run{background:var(--ok)}
    .status-dot.stop{background:var(--bad)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .field{display:flex;gap:6px;align-items:center}
    input[type=number]{width:80px;background:#0e1630;border:1px solid #21305d;border-radius:8px;color:var(--fg);padding:6px 8px}
    .hint{color:var(--muted);font-size:12px}
    .tabs{display:flex;gap:8px;margin-bottom:8px}
    .tabs button{padding:8px 10px;border-radius:10px}
    .tabs .active{background:#25305b}
    canvas{background:#0a1127;border-radius:10px;padding:8px}
    .grid{display:grid;gap:8px}
    .grid.cols-4{grid-template-columns:repeat(4,minmax(0,1fr))}
    .grid.cols-auto{grid-template-columns:repeat(auto-fit,minmax(120px,1fr))}
  </style>
</head>
<body>
  <h1>Met One 3315 – WebSerial Interface <span class="pill"><i class="status-dot" id="modeDot"></i><span id="modeText">DISCONNECTED</span></span></h1>

  <div class="row wrap">
    <!-- Status & Controls -->
    <div class="card" style="max-width:980px">
      <div class="row" style="gap:12px">
        <div class="kv"><b>Port</b><span id="portName">—</span></div>
        <div class="kv"><b>Model</b><span id="model">—</span></div>
        <div class="kv"><b>Mode</b><span id="mode">Idle</span></div>
      </div>

      <div class="controls">
        <button id="btnConnect" class="primary">Connect</button>
        <button id="btnDisconnect" class="ghost" disabled>Disconnect</button>
      </div>

      <div class="controls" style="border-top:1px solid var(--line);padding-top:10px">
        <button id="btnEnterUniversal">Enter Universal ('U' until echo)</button>
        <button id="btnIdentify" disabled>Identify ('T')</button>
        <button id="btnAuto" disabled>Auto Start ('a'+'d')</button>
        <button id="btnPollOnce" disabled>Poll Record Once ('A')</button>
        <button id="btnStandby" class="ghost" disabled>Standby ('h')</button>
        <button id="btnClearDevice" class="ghost" disabled>Clear device buffer ('C')</button>
        <span class="hint">Idle after Connect. Nothing runs until you press a button.</span>
      </div>

      <div class="controls" style="border-top:1px solid var(--line);padding-top:10px">
        <button id="btnPickFile" disabled>Pick CSV file…</button>
        <span class="field">Every <input id="saveEvery" type="number" min="1" value="10"> s</span>
        <button id="btnAutoSaveEnable" disabled>Enable Auto‑Save</button>
        <button id="btnAutoSaveDisable" disabled>Stop Auto‑Save</button>
        <button id="btnExportNow" disabled>Export Buffer CSV</button>
        <button id="btnClearLocal" disabled>Clear Local Buffer</button>
        <span class="hint" id="saveHint">auto‑save not set</span>
      </div>
    </div>

    <!-- Tabs: Raw / Latest / Graphs -->
    <div class="card" style="min-width:320px;max-width:980px">
      <div class="tabs">
        <button data-tab="raw" class="active">Raw</button>
        <button data-tab="latest">Latest</button>
        <button data-tab="graphs">Graphs</button>
      </div>

      <!-- Raw terminal -->
      <div id="tab-raw">
        <div id="terminal"></div>
      </div>

      <!-- Latest: dynamic channels (A/V optional and omitted from CSV) -->
      <div id="tab-latest" hidden>
        <div class="grid cols-4">
          <div class="kv"><b>Date</b><span id="kvDate">—</span></div>
          <div class="kv"><b>Time</b><span id="kvTime">—</span></div>
          <div class="kv"><b>Period (s)</b><span id="kvPeriod">—</span></div>
          <div class="kv"><b>Location</b><span id="kvLoc">—</span></div>
        </div>
        <div class="grid cols-auto" id="latestChannels" style="margin-top:8px"></div>
        <div class="grid cols-4" style="margin-top:8px">
          <div class="kv"><b>Flow</b><span id="kvFLO">—</span></div>
          <div class="kv"><b>Checksum</b><span id="kvCS">—</span></div>
        </div>
      </div>

      <!-- Graphs: dynamic channel series (by size label) + Flow -->
      <div id="tab-graphs" hidden>
        <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:8px">
          <button id="btnPause">Pause</button>
          <label><input type="checkbox" id="chkAutoY" checked> Auto Y‑axis</label>
        </div>
        <div class="row wrap">
          <div class="card" style="min-width:300px"><canvas id="chartCounts"></canvas></div>
          <div class="card" style="min-width:300px"><canvas id="chartFLO"></canvas></div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /************************************************************
   * Helpers & UI
   ************************************************************/
  const $ = (s)=>document.querySelector(s);
  const $$ = (s)=>document.querySelectorAll(s);
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const logEl = $('#terminal');
  function log(msg, dir='sys'){ const ts = new Date().toLocaleTimeString(); const arrow = dir==='tx'?'→':dir==='rx'?'←':'*'; logEl.textContent += `[${ts}] ${arrow} ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }
  function setMode(m){ $('#mode').textContent=m; $('#modeText').textContent=m; const d=$('#modeDot'); d.className='status-dot'; if(m==='Counting') d.classList.add('run'); if(m==='Stopped') d.classList.add('stop'); }
  function setModel(s){ $('#model').textContent=s||'—'; }

  function updateUi(){
    const connected = !!port;
    $('#btnEnterUniversal').disabled = !connected || universalOK;
    $('#btnIdentify').disabled       = !connected || !universalOK;
    $('#btnAuto').disabled           = !connected || !universalOK;
    $('#btnPollOnce').disabled       = !connected || !universalOK;
    $('#btnStandby').disabled        = !connected || !universalOK;
    $('#btnClearDevice').disabled    = !connected || !universalOK;

    $('#btnPickFile').disabled       = !connected;
    $('#btnExportNow').disabled      = !connected;
    $('#btnClearLocal').disabled     = !connected;
    $('#btnAutoSaveEnable').disabled = !connected;
  }

  /************************************************************
   * Serial state & basic I/O with a simple lock to avoid overlap
   ************************************************************/
  let port, writer;                  // WebSerial
  let universalOK = false;           // set after 'U' echo
  let autoTimer = null;              // setInterval handle for 1 Hz 'A'
  let modeTimer = null;              // 1.5 s 'M' polling after Universal
  let ioBusy = false;                // prevents overlapping readers

  async function writeChar(ch){ if(!writer) return; await writer.write(new Uint8Array([ch.charCodeAt(0)])); log(`'${ch}'`,'tx'); }

  async function readLine({timeoutMs=2500, drainMs=80}={}){
    if(!port) return '';
    const reader = port.readable.getReader();
    const td = new TextDecoder(); let text=''; let timer;
    try{
      timer = setTimeout(()=>{ try{ reader.cancel(); }catch{} }, timeoutMs);
      while(true){
        const { value, done } = await reader.read();
        if(done) break;
        if(value){
          text += td.decode(value,{stream:true});
          if(/\r|\n/.test(text)){
            await sleep(drainMs);
            const tail = await reader.read();
            if(tail && tail.value) text += td.decode(tail.value,{stream:true});
            break;
          }
        }
      }
    }catch(_){/* timeout ok */}
    finally{ clearTimeout(timer); reader.releaseLock(); }
    const t=text.trim(); if(t) log(JSON.stringify(t),'rx'); return t;
  }

  async function readChar({timeoutMs=800}={}){
    if(!port) return '';
    const reader = port.readable.getReader();
    const td = new TextDecoder(); let out=''; let timer;
    try{ timer=setTimeout(()=>{ try{reader.cancel();}catch{} }, timeoutMs); const {value}=await reader.read(); if(value) out=td.decode(value).trim(); }
    catch(_){/* timeout ok */}
    finally{ clearTimeout(timer); reader.releaseLock(); }
    if(out) log(JSON.stringify(out),'rx');
    return out;
  }

  /************************************************************
   * CSV export & auto‑save – dynamic per‑channel columns
   *  • Removes ChannelSizes/ChannelCounts, Raw, and A/V columns
   *  • Date:  MMDDYY → DD/MM/YY, Time: HHMMSS → HH:MM:SS
   *  • Sanitizes channel labels to avoid header pollution
   ************************************************************/
  let fileHandle=null, autosave=false, autosaveTimer=null;
  let sampleIndex=0; const buffer=[]; const pendingLines=[];
  const channelOrder=[]; // e.g., ["0.3","0.5","1.0"] in first-seen order

  function _isDigits(str){ if(typeof str!=="string"||!str.length) return false; for(let i=0;i<str.length;i++){ const c=str.charCodeAt(i); if(c<48||c>57) return false; } return true; }
  function isValidSizeLabel(sz){ if(typeof sz!=="string") return false; const parts=sz.split('.'); if(parts.length>2) return false; if(!_isDigits(parts[0])) return false; if(parts.length===2 && (!_isDigits(parts[1])||parts[1].length>2)) return false; const v=parseFloat(sz); return isFinite(v)&&v>0&&v<=1000; }
  function sanitizeChannels(ch){ const out={}; if(!ch) return out; for(const k in ch){ if(!Object.prototype.hasOwnProperty.call(ch,k)) continue; const v=ch[k]; if(!isValidSizeLabel(k)) continue; const n=Number(v); if(!Number.isFinite(n)||n<0) continue; out[k]=Math.trunc(n); } return out; }

  function fmtDate(s){ if(typeof s==='string'&&s.length===6&&_isDigits(s)){ const mm=s.slice(0,2), dd=s.slice(2,4), yy=s.slice(4,6); return `${dd}/${mm}/${yy}`; } return s||''; }
  function fmtTime(s){ if(typeof s==='string'&&s.length===6&&_isDigits(s)){ const hh=s.slice(0,2), mi=s.slice(2,4), ss=s.slice(4,6); return `${hh}:${mi}:${ss}`; } return s||''; }

  function headerRow(){ const base=['ISO_TS','SampleIndex','Date','Time','Period']; const chanCols=channelOrder.map(sz=>'Ch '+sz); const tail=['Flow','Location','Checksum']; return base.concat(chanCols).concat(tail); }

  function recordToRow(r){
    const cleanChannels = sanitizeChannels(r.channels);
    Object.keys(cleanChannels).forEach(sz=>{ if(!channelOrder.includes(sz)) channelOrder.push(sz); });
    const dateOk = !r.date || (typeof r.date==='string'&&r.date.length===6&&_isDigits(r.date));
    const timeOk = !r.time || (typeof r.time==='string'&&r.time.length===6&&_isDigits(r.time));
    const hasAnyChannel = Object.keys(cleanChannels).length>0;
    if(!hasAnyChannel && !(dateOk&&timeOk)){ log('Discarded malformed record for CSV (no valid channels & bad date/time)'); return null; }

    const iso=new Date().toISOString();
    const row=[ iso, sampleIndex, fmtDate(r.date), fmtTime(r.time), (r.period||'') ];
    channelOrder.forEach(sz=>row.push(cleanChannels.hasOwnProperty(sz)?cleanChannels[sz]:''));
    row.push( (r.flow!=null?r.flow:''), (r.location!=null?r.location:''), (r.checksum!=null?r.checksum:'') );
    return row;
  }

  function csvEscape(s){ if(s==null) return ''; const t=String(s); return /[",\n]/.test(t)? '"'+t.replace(/"/g,'""')+'"': t; }
  function toCSV(rows){ return rows.map(r=>r.map(csvEscape).join(',')).join('\n'); }
  function setSaveHint(msg){ $('#saveHint').textContent=msg; }

  async function pickFile(){ if(!window.showSaveFilePicker){ setSaveHint('File System Access API not supported'); return; } try{ fileHandle=await window.showSaveFilePicker({ suggestedName:'metone_records.csv', types:[{ description:'CSV', accept:{'text/csv':['.csv']} }] }); const w=await fileHandle.createWritable(); await w.write(toCSV([headerRow()])+'\n'); await w.close(); setSaveHint('Chosen: '+(fileHandle.name||'metone_records.csv')); }catch(e){ setSaveHint('No file chosen'); } }
  async function flushAutosave(){ if(!autosave||!fileHandle||pendingLines.length===0) return; try{ const w=await fileHandle.createWritable({keepExistingData:true}); const f=await fileHandle.getFile(); await w.seek(f.size); await w.write(toCSV(pendingLines)+'\n'); await w.close(); pendingLines.length=0; }catch(e){ log('Auto‑save error: '+e); } }
  function enableAutosave(){ if(!fileHandle){ setSaveHint('Pick a CSV file first'); return; } autosave=true; const sec=Math.max(1, parseInt($('#saveEvery').value||'10')); $('#btnAutoSaveEnable').disabled=true; $('#btnAutoSaveDisable').disabled=false; setSaveHint('Auto‑saving every '+sec+'s'); autosaveTimer=setInterval(flushAutosave, sec*1000); }
  function disableAutosave(){ autosave=false; if(autosaveTimer) clearInterval(autosaveTimer); autosaveTimer=null; $('#btnAutoSaveEnable').disabled=false; $('#btnAutoSaveDisable').disabled=true; setSaveHint('Auto‑save stopped'); }
  function downloadCSVNow(){ if(buffer.length===0){ log('No buffered records to export'); return; } const rows=[headerRow(), ...buffer.map(recordToRow).filter(r=>Array.isArray(r))]; const csv=toCSV(rows); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); const ts=new Date().toISOString().replace(/[:T]/g,'-').slice(0,19); a.href=url; a.download=`metone_3315_records_${ts}.csv`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); log('CSV exported'); }
  function clearLocal(){ buffer.length=0; sampleIndex=0; pendingLines.length=0; log('Cleared local buffer'); }

  /************************************************************
   * Tabs & Charts
   ************************************************************/
  $$('.tabs button').forEach(btn=>btn.addEventListener('click',()=>{
    $$('.tabs button').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    $('#tab-raw').hidden    = btn.dataset.tab!=='raw';
    $('#tab-latest').hidden = btn.dataset.tab!=='latest';
    $('#tab-graphs').hidden = btn.dataset.tab!=='graphs';
  }));

  const labels=[]; const seriesMap=new Map(); const floData=[]; let paused=false;
  const chartCounts=new Chart($('#chartCounts'),{ type:'line', data:{ labels, datasets:[] }, options:{ responsive:true, animation:false, scales:{ y:{ beginAtZero:true } } } });
  const chartFLO=new Chart($('#chartFLO'),{ type:'line', data:{ labels, datasets:[{ label:'Flow', data:floData }] }, options:{ responsive:true, animation:false, scales:{ y:{ beginAtZero:true } } } });
  $('#btnPause').onclick=()=>{ paused=!paused; $('#btnPause').textContent = paused?'Resume':'Pause'; };
  $('#chkAutoY').onchange=()=>{ [chartCounts,chartFLO].forEach(c=>{ c.options.scales.y.beginAtZero=$('#chkAutoY').checked; c.update('none'); }); };

  function ensureDataset(sizeLabel){ if(seriesMap.has(sizeLabel)) return; const arr=[]; seriesMap.set(sizeLabel,arr); chartCounts.data.datasets.push({ label:`${sizeLabel} µm`, data:arr }); }
  function pushSeries(parsed){
    const t = parsed.time || new Date().toLocaleTimeString();
    labels.push(t); if(labels.length>300) labels.shift();
    // extend all series by 0 first
    seriesMap.forEach(a=>{ a.push(0); if(a.length>300) a.shift(); });
    // set actual values for present sizes
    Object.entries(parsed.channels||{}).forEach(([sz,cnt])=>{ ensureDataset(sz); const arr=seriesMap.get(sz); arr[arr.length-1]=Number(cnt||0); });
    // flow
    floData.push(Number(parsed.flow||0)); if(floData.length>300) floData.shift();
    if(!paused){ chartCounts.update('none'); chartFLO.update('none'); }
  }

  /************************************************************
   * Protocol – full flow per your spec
   *  • Connect: open port only (no auto actions)
   *  • Enter Universal: send 'U' until echoed; then start 'M' polling
   *  • Identify: send 'T' (manual button)
   *  • Auto: send 'a' then 'd', then poll 'A' at 1 Hz
   *  • Standby: send 'h' and stop auto loop
   *  • Clear device buffer: 'C'
   ************************************************************/
  async function connect(){
    try{
      port = await navigator.serial.requestPort({});
      await port.open({ baudRate:9600, dataBits:8, stopBits:1, parity:'none', bufferSize:8192 });
      writer = port.writable.getWriter();
      $('#portName').textContent = 'Serial Port';
      log('Connected');
      $('#btnDisconnect').disabled=false; $('#btnConnect').disabled=true;
      updateUi();
    }catch(e){ log('Connect error: '+e); }
  }

  async function disconnect(){
    stopAuto(); stopModePolling();
    try{ if(writer){ writer.releaseLock(); writer=null; } }catch{}
    try{ if(port){ await port.close(); port=null; } }catch{}
    universalOK=false; setMode('Idle');
    $('#btnDisconnect').disabled=true; $('#btnConnect').disabled=false;
    updateUi();
    log('Disconnected');
  }

  async function enterUniversal(){
    if(!port) return;
    for(let i=0;i<10;i++){
      await writeChar('U');
      await sleep(200);
      const resp = await readChar({timeoutMs:600});
      if((resp||'').toUpperCase().includes('U')){
        log('Universal mode acknowledged');
        universalOK = true;
        updateUi();
        startModePolling(); // begin 'M' polling every ~1.5s
        return true;
      }
      log('No response, retrying…');
      await sleep(800);
    }
    log('Universal mode failed');
    return false;
  }

  async function identify(){ if(!universalOK) return; await writeChar('T'); const s=await readLine({timeoutMs:1500}); if(s){ setModel(s.split(/\s+/)[0]); } }

  function startAuto(){ if(!universalOK) return; stopAuto(); autoTimer=setInterval(requestRecord,1000); setMode('Counting'); }
  function stopAuto(){ if(autoTimer) clearInterval(autoTimer); autoTimer=null; }

  async function autoCommand(){ if(!universalOK) return; await writeChar('a'); await sleep(50); await writeChar('d'); startAuto(); }
  async function standby(){ if(!universalOK) return; await writeChar('h'); setMode('Stopped'); stopAuto(); }
  async function clearDeviceBuffer(){ if(!universalOK) return; await writeChar('C'); log('Requested device buffer clear (C).'); }
  async function pollOnce(){ if(!universalOK) return; await requestRecord(); }

  // Mode polling with simple lock – starts after Universal
  async function pollMode(){
    if(!universalOK || ioBusy) return;
    ioBusy = true;
    try{
      await writeChar('M');
      const r = await readChar({timeoutMs:300});
      const c = (r||'').trim().toUpperCase();
      if(c.startsWith('C')) setMode('Counting');
      else if(c.startsWith('H')) setMode('Holding');
      else if(c.startsWith('S')) setMode('Stopped');
    }catch(_){/* ignore */}
    finally{ ioBusy = false; }
  }
  function startModePolling(){ stopModePolling(); modeTimer=setInterval(pollMode,1500); }
  function stopModePolling(){ if(modeTimer) clearInterval(modeTimer); modeTimer=null; }

  /************************************************************
   * Record parsing & loop
   * Format: Date Time Period then <Size> <Count> pairs until a tag.
   * Tags after channels: A/V (optional), FLO, LOC, C/S (order may vary)
   ************************************************************/
  const TAGS=new Set(['A/V','FLO','LOC','C/S']);
  function looksLikeSize(tok){ return /^\d+(?:\.\d+)?$/.test(tok); }

  function parseRecord(s){
    try{
      const parts = s.trim().split(/\s+/);
      if(parts[0]==='$' || /^A[`\s]?/.test(parts[0])) parts.shift();
      const out={ date:parts[0], time:parts[1], period:parts[2], channels:{}, flow:null, location:null, checksum:null, raw:s.trim() };
      let i=3;
      while(i+1<parts.length && looksLikeSize(parts[i]) && !TAGS.has(parts[i])){
        const size = parts[i].replace(/\.$/,'');
        const cnt  = parseInt((parts[i+1]||'').replace(/[^0-9]/g,''))||0;
        out.channels[size]=cnt; i+=2;
      }
      while(i+1<parts.length){
        const tag=parts[i], val=parts[i+1];
        if(tag==='FLO') out.flow = parseInt(val)||0;
        else if(tag==='LOC') out.location = parseInt(val)||0;
        else if(tag==='C/S') out.checksum = val;
        // A/V may be present but is ignored for CSV per spec
        i+=2;
      }
      return out;
    }catch(e){ log('Parse error: '+e); return null; }
  }

  function renderLatest(parsed){
    $('#kvDate').textContent   = fmtDate(parsed.date);
    $('#kvTime').textContent   = fmtTime(parsed.time);
    $('#kvPeriod').textContent = parsed.period||'—';
    $('#kvLoc').textContent    = (parsed.location!=null?parsed.location:'—');
    $('#kvFLO').textContent    = (parsed.flow!=null?parsed.flow:'—');
    $('#kvCS').textContent     = (parsed.checksum!=null?parsed.checksum:'—');
    const host=$('#latestChannels'); host.innerHTML='';
    for(const [sz,cnt] of Object.entries(parsed.channels||{})){
      const div=document.createElement('div'); div.className='kv';
      div.innerHTML = `<b>${sz} µm</b><span>${cnt}</span>`;
      host.appendChild(div);
    }
  }

  async function requestRecord(){
    if(ioBusy) return; ioBusy = true;
    try{
      await writeChar('A');
      const line = await readLine({timeoutMs:2500, drainMs:80});
      if(!line) return; const t=line.trim(); if(/^A#/.test(t)) return; // no data yet
      let rec=t; if(/^A[\s`]/.test(rec)) rec=rec.replace(/^A[\s`]*/, ''); if(/^\$\s*/.test(rec)) rec=rec.replace(/^\$\s*/, '');
      log('Record: '+rec);
      const parsed = parseRecord(rec); if(!parsed){ log('Record parse failed'); return; }
      // Update UI & graphs
      renderLatest(parsed); pushSeries(parsed);
      // CSV queues (defensive row building)
      const row = recordToRow({ ...parsed, index: sampleIndex });
      if(Array.isArray(row)){ sampleIndex++; buffer.push(parsed); pendingLines.push(row); }
    } finally { ioBusy = false; }
  }

  /************************************************************
   * Wire UI
   ************************************************************/
  $('#btnConnect').onclick=connect; $('#btnDisconnect').onclick=disconnect;
  $('#btnEnterUniversal').onclick=enterUniversal; $('#btnIdentify').onclick=identify;
  $('#btnAuto').onclick=autoCommand; $('#btnPollOnce').onclick=pollOnce;
  $('#btnStandby').onclick=standby; $('#btnClearDevice').onclick=clearDeviceBuffer;

  $('#btnPickFile').onclick=pickFile; $('#btnAutoSaveEnable').onclick=enableAutosave;
  $('#btnAutoSaveDisable').onclick=disableAutosave; $('#btnExportNow').onclick=downloadCSVNow;
  $('#btnClearLocal').onclick=clearLocal;

  // Initial capability check
  if(!('serial' in navigator)){
    log('WebSerial not supported in this browser. Use a recent Chrome/Edge.');
    $('#btnConnect').disabled=true;
  }
  </script>
</body>
</html>
