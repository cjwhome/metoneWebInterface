<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Met One 3315 – WebSerial Interface</title>
  <style>
    :root{--bg:#0b1020;--card:#121a33;--muted:#9fb0d0;--fg:#e7efff;--acc:#66d0ff;--ok:#32d296;--warn:#ffdd57;--bad:#ff6b6b;--btn:#1b2547}
    *{box-sizing:border-box}
    body{margin:0;padding:24px;background:var(--bg);color:var(--fg);font:14px/1.4 Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    h1{margin:0 0 16px 0;font-size:20px}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 12px 30px rgba(0,0,0,.25);flex:1}
    .kv{background:#0e1630;padding:8px 10px;border-radius:10px}
    .kv b{display:block;font-size:12px;color:var(--muted)}
    .kv span{font-size:14px}
    button{background:var(--btn);color:var(--fg);border:1px solid #273160;border-radius:10px;padding:10px 14px;cursor:pointer}
    button.primary{background:var(--acc);color:#06121e;border-color:transparent;font-weight:700}
    button.ghost{background:transparent}
    button:disabled{opacity:.5;cursor:not-allowed}
    #terminal{height:260px;overflow:auto;background:#0a1127;border-radius:10px;padding:10px;font-family:ui-monospace,Consolas,monospace;font-size:12px;white-space:pre-wrap}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0e1630;border:1px solid #21305d}
    .status-dot{width:8px;height:8px;border-radius:999px;background:var(--warn)}
    .status-dot.run{background:var(--ok)}
    .status-dot.stop{background:var(--bad)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    .field{display:flex;gap:6px;align-items:center}
    input[type=number]{width:80px;background:#0e1630;border:1px solid #21305d;border-radius:8px;color:var(--fg);padding:6px 8px}
    .hint{color:var(--muted);font-size:12px}
  </style>
</head>
<body>
  <h1>Met One 3315 – WebSerial Interface <span class="pill"><i class="status-dot" id="modeDot"></i><span id="modeText">DISCONNECTED</span></span></h1>

  <div class="row wrap">
    <div class="card" style="max-width:560px">
      <div class="row" style="gap:12px">
        <div class="kv"><b>Port</b><span id="portName">—</span></div>
        <div class="kv"><b>Model</b><span id="model">—</span></div>
        <div class="kv"><b>Mode</b><span id="mode">Idle</span></div>
      </div>
      <div class="controls">
        <button id="btnConnect" class="primary">Connect</button>
        <button id="btnDisconnect" class="ghost" disabled>Disconnect</button>
      </div>
      <div class="controls" style="border-top:1px solid #223055;padding-top:10px">
        <button id="btnEnterUniversal">Enter Universal ('U' until echo)</button>
        <button id="btnIdentify" disabled>Identify ('T')</button>
        <button id="btnAuto" disabled>Auto Start ('a'+'d')</button>
        <button id="btnPollOnce" disabled>Poll Record Once ('A')</button>
        <button id="btnStandby" class="ghost" disabled>Standby ('h')</button>
        <button id="btnClearDevice" class="ghost" disabled>Clear buffer ('C')</button>
        <span class="hint">No automatic actions after connect. Idle until you choose a command.</span>
      </div>
    </div>

    <div class="card" style="min-width:320px;max-width:640px">
      <div id="terminal"></div>
    </div>
  </div>

  <script>
  const $ = (s)=>document.querySelector(s);
  const logEl = $('#terminal');
  function log(msg, dir='sys'){ const ts = new Date().toLocaleTimeString(); const line = `[${ts}] ${dir==='tx'?'→':dir==='rx'?'←':'*'} ${msg}`; logEl.textContent += line+"\n"; logEl.scrollTop = logEl.scrollHeight; }
  function setMode(m){ $('#mode').textContent=m; $('#modeText').textContent=m; const d=$('#modeDot'); d.className='status-dot'; if(m==='Counting') d.classList.add('run'); if(m==='Stopped') d.classList.add('stop'); }
  function setModel(s){ $('#model').textContent=s||'—'; }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // --- Serial state ---
  let port, writer;
  let autoTimer=null;
  let universalOK=false;

  // Robust line reader: read until CR/LF, then short drain to catch tail bytes
  async function readLine({timeoutMs=2500, drainMs=40}={}){
    if(!port) return '';
    const reader = port.readable.getReader();
    const td = new TextDecoder();
    let text='';
    let timer;
    try{
      timer = setTimeout(()=>{ try{ reader.cancel(); }catch{} }, timeoutMs);
      while(true){
        const {value, done} = await reader.read();
        if(done) break;
        if(value){
          text += td.decode(value, {stream:true});
          if(/[\r\n]/.test(text)){
            // brief drain to grab any remaining bytes after newline
            await sleep(drainMs);
            const { value:rest } = await reader.read();
            if(rest) text += td.decode(rest, {stream:true});
            break;
          }
        }
      }
    }catch(e){ /* timeout or cancel */ }
    finally{ clearTimeout(timer); reader.releaseLock(); }
    const t = text.trim(); if(t) log(JSON.stringify(t),'rx');
    return t;
  }

  async function readChar({timeoutMs=800}={}){
    if(!port) return '';
    const reader = port.readable.getReader();
    const td = new TextDecoder();
    let out='';
    let timer;
    try{
      timer = setTimeout(()=>{ try{ reader.cancel(); }catch{} }, timeoutMs);
      const {value} = await reader.read();
      if(value) out = td.decode(value).trim();
    }catch(e){}
    finally{ clearTimeout(timer); reader.releaseLock(); }
    if(out) log(JSON.stringify(out),'rx');
    return out;
  }

  async function writeChar(ch){ if(!writer) return; await writer.write(new Uint8Array([ch.charCodeAt(0)])); log(`'${ch}'`,'tx'); }

  // --- Protocol ---
  async function connect(){
    try{
      port = await navigator.serial.requestPort({});
      await port.open({ baudRate:9600, dataBits:8, stopBits:1, parity:'none', bufferSize: 8192 }); // larger buffer for full records
      writer = port.writable.getWriter();
      $('#portName').textContent='Serial Port';
      log('Connected');
      $('#btnDisconnect').disabled=false;
      $('#btnConnect').disabled=true;
      // Do NOT auto-start anything else; require user to press Enter Universal
      enablePostConnect(true);
    }catch(e){ log('Connect error: '+e); }
  }

  async function disconnect(){ stopAuto(); try{ if(writer){ writer.releaseLock(); writer=null; } }catch{} try{ if(port){ await port.close(); port=null; } }catch{} $('#btnDisconnect').disabled=true; $('#btnConnect').disabled=false; universalOK=false; enablePostConnect(false); setMode('Idle'); log('Disconnected'); }

  function enablePostConnect(enabled){ ['#btnEnterUniversal','#btnIdentify','#btnAuto','#btnPollOnce','#btnStandby','#btnClearDevice'].forEach(id=>$(id).disabled = !enabled); }

  async function enterUniversal(){
    if(!port) return;
    for(let i=0;i<10;i++){
      await writeChar('U');
      await sleep(200);
      const resp = await readChar({timeoutMs:600});
      if(resp.toUpperCase().includes('U')){ log('Universal mode acknowledged'); universalOK=true; $('#btnIdentify').disabled=false; $('#btnAuto').disabled=false; $('#btnStandby').disabled=false; $('#btnPollOnce').disabled=false; $('#btnClearDevice').disabled=false; return true; }
      log('No response, retrying…');
      await sleep(800);
    }
    log('Universal mode failed');
    return false;
  }

  async function identify(){ if(!universalOK) return; await writeChar('T'); const s = await readLine({timeoutMs:1500}); if(s){ setModel(s.split(/\s+/)[0]); } }

  function startAuto(){ if(!universalOK) return; stopAuto(); autoTimer = setInterval(requestRecord, 1000); }
  function stopAuto(){ if(autoTimer) clearInterval(autoTimer); autoTimer=null; }

  async function autoCommand(){ if(!universalOK) return; await writeChar('a'); await sleep(50); await writeChar('d'); startAuto(); setMode('Counting'); }

  async function standby(){ if(!universalOK) return; await writeChar('h'); setMode('Stopped'); stopAuto(); }

  async function clearDeviceBuffer(){ if(!universalOK) return; await writeChar('C'); log('Requested device buffer clear (C).'); }

  async function pollOnce(){ if(!universalOK) return; await requestRecord(); }

  function parseRecord(s){ try{ const parts=s.trim().split(/\s+/); if(parts[0]==='$' || /^A[`\s]?/.test(parts[0])) parts.shift(); const out={date:parts[0],time:parts[1],period:parts[2],channels:{},av:null,flow:null,loc:null,cs:null,raw:s.trim()}; let i=3; for(let k=0;k<6 && i+1<parts.length;k++){ const size=parts[i].replace(/\.$/,''); const cnt=parseInt(parts[i+1].replace(/[^0-9]/g,''))||0; out.channels[size]=cnt; i+=2; } while(i+1<parts.length){ const tag=parts[i]; const val=parts[i+1]; if(tag==='A/V') out.av=parseInt(val)||0; else if(tag==='FLO') out.flow=parseInt(val)||0; else if(tag==='LOC') out.loc=parseInt(val)||0; else if(tag==='C/S') out.cs=val; i+=2; } return out; }catch(e){ log('Parse error: '+e); return null; } }

  async function requestRecord(){ await writeChar('A'); const line = await readLine({timeoutMs:2000, drainMs:80}); if(!line) return; const t=line.trim(); if(/^A#/.test(t)) return; let rec = t; if(/^A[\s`]/.test(rec)) rec = rec.replace(/^A[\s`]*/, ''); if(/^\$\s*/.test(rec)) rec = rec.replace(/^\$\s*/, ''); log('Record: '+rec); const parsed = parseRecord(rec); if(!parsed){ log('Record parse failed'); return; } // You can update UI/graphs here as needed.
  }

  // --- Wire UI ---
  $('#btnConnect').onclick = connect;
  $('#btnDisconnect').onclick = disconnect;
  $('#btnEnterUniversal').onclick = enterUniversal;
  $('#btnIdentify').onclick = identify;
  $('#btnAuto').onclick = autoCommand;
  $('#btnPollOnce').onclick = pollOnce;
  $('#btnStandby').onclick = standby;
  $('#btnClearDevice').onclick = clearDeviceBuffer;

  if(!('serial' in navigator)){
    log('WebSerial not supported in this browser. Use a recent Chrome/Edge.');
    $('#btnConnect').disabled = true;
  }
  </script>
</body>
</html>
