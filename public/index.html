<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Met One OPC – WebSerial Interface</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --bg: #0b1020;
        --card: #121a33;
        --muted: #9fb0d0;
        --fg: #e7efff;
        --acc: #66d0ff;
        --ok: #32d296;
        --warn: #ffdd57;
        --bad: #ff6b6b;
        --btn: #1b2547;
        --line: #223055;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 24px;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto,
          sans-serif;
      }
      h1 {
        margin: 0 0 16px 0;
        font-size: 20px;
      }
      .row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
      }
      .card {
        background: var(--card);
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
        flex: 1;
      }
      .kv {
        background: #0e1630;
        padding: 8px 10px;
        border-radius: 10px;
      }
      .kv b {
        display: block;
        font-size: 12px;
        color: var(--muted);
      }
      .kv span {
        font-size: 14px;
      }
      button {
        background: var(--btn);
        color: var(--fg);
        border: 1px solid #273160;
        border-radius: 10px;
        padding: 10px 14px;
        cursor: pointer;
      }
      button.primary {
        background: var(--acc);
        color: #06121e;
        border-color: transparent;
        font-weight: 700;
      }
      button.ghost {
        background: transparent;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      #terminal {
        height: 260px;
        overflow: auto;
        background: #0a1127;
        border-radius: 10px;
        padding: 10px;
        font-family: ui-monospace, Consolas, monospace;
        font-size: 12px;
        white-space: pre-wrap;
        border: 1px solid var(--line);
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border-radius: 999px;
        background: #0e1630;
        border: 1px solid #21305d;
      }
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--warn);
      }
      .status-dot.run {
        background: var(--ok);
      }
      .status-dot.stop {
        background: var(--bad);
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 12px;
      }
      .field {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      input[type="number"] {
        width: 80px;
        background: #0e1630;
        border: 1px solid #21305d;
        border-radius: 8px;
        color: var(--fg);
        padding: 6px 8px;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
      }
      .tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }
      .tabs button {
        padding: 8px 10px;
        border-radius: 10px;
      }
      .tabs .active {
        background: #25305b;
      }
      canvas {
        background: #0a1127;
        border-radius: 10px;
        padding: 8px;
      }
      .grid {
        display: grid;
        gap: 8px;
      }
      .grid.cols-4 {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
      .grid.cols-auto {
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }
      .chart-box {
        position: relative;
        height: 300px; /* <- this gives Chart.js something to size to */
        width: 100%;
      }

      #chartCounts,
      #chartFLO {
        display: block; /* ensure block-level so it fills the parent */
      }

      /* Vertical stack layout instead of side-by-side */
      .stack {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* Keep controls compact */
      .controls-card {
        /* optional: prevents controls card from stretching too tall */
        padding-bottom: 12px;
      }

      /* Let the tabs area dominate */
      .tabs-card {
        flex: 1; /* grow to fill remaining vertical space when available */
        width: 100%; /* use full width */
      }

      /* If you want the graphs/tabs to have a minimum height */
      #tab-graphs .row .card .chart-box {
        height: 300px; /* you already set this; keep/tweak as desired */
      }

      /* OPTIONAL: if you have global .card { flex: 1; } and it causes tall controls:
   override here so the controls card doesn't stretch vertically */
      .controls-card {
        flex: 0 0 auto;
      }

      /* Highlights for prominent actions */
      button.emphasis-green {
        background: #32d296; /* bright green */
        color: #06121e;
        border-color: transparent;
        font-weight: 700;
      }
      button.emphasis-red {
        background: #ff6b6b; /* bright red */
        color: #06121e;
        border-color: transparent;
        font-weight: 700;
      }

      @media (min-width: 900px) {
        .tabs-card {
          /* just examples; tweak to taste */
          padding: 16px 20px;
        }
      }

      /* Compact horizontal toolbar */
      .toolbar {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap; /* wrap on narrow screens */
        margin-top: 8px;
      }

      /* Make buttons smaller & tighter */
      button.compact {
        padding: 6px 10px; /* was 10px 14px */
        font-size: 12px; /* was 14px */
        border-radius: 8px; /* was 10px */
      }

      /* Inputs inline and compact */
      .field.compact input[type="number"] {
        width: 64px; /* was 80px */
        padding: 4px 6px; /* was 6px 8px */
        font-size: 12px;
      }

      /* Dim hints and keep inline */
      .hint.inline {
        margin-left: 6px;
        font-size: 12px;
        opacity: 0.8;
      }

      /* Optional: push right-side items to the end */
      .toolbar .spacer {
        flex: 1;
      }
    </style>
  </head>
  <body>
    <h1>
      Met One OPC – WebSerial Interface
      <span class="pill"
        ><i class="status-dot" id="modeDot"></i
        ><span id="modeText">DISCONNECTED</span></span
      >
    </h1>

    <div class="stack">
      <div class="card controls-card">
        <div class="row" style="gap: 12px">
          <div class="kv"><b>Port</b><span id="portName">—</span></div>
          <div class="kv"><b>Model</b><span id="model">—</span></div>
          <div class="kv"><b>Mode</b><span id="mode">Idle</span></div>
        </div>
      </div>
      <div class="toolbar">
        <!-- Left group: connection + start -->
        <button id="btnConnect" class="primary compact">Connect</button>
        <button id="btnDisconnect" class="ghost compact" disabled>
          Disconnect
        </button>
        <button id="btnStartCounting" class="compact" disabled>
          Start Counting
        </button>

        <button id="btnStandby" class="ghost compact" disabled>STOP</button>
        <button id="btnClearDevice" class="ghost compact" disabled>
          Clear Buffer
        </button>

        <span class="spacer"></span>

        <!-- Right group: CSV/autosave -->
        <button id="btnExportNow" class="compact" disabled>Export CSV</button>
        <button id="btnClearLocal" class="ghost compact" disabled>
          Clear Local
        </button>
      </div>

      <div class="card tabs-card">
        <div class="tabs">
          <button data-tab="raw">Raw</button>
          <button data-tab="latest" class="active">Latest</button>
          <button data-tab="graphs">Graphs</button>
        </div>

        <div id="tab-raw" hidden>
          <div id="terminal"></div>
        </div>

        <div id="tab-latest">
          <div class="grid cols-4">
            <div class="kv"><b>Date</b><span id="kvDate">—</span></div>
            <div class="kv"><b>Time</b><span id="kvTime">—</span></div>
            <div class="kv"><b>Period (s)</b><span id="kvPeriod">—</span></div>
            <div class="kv"><b>Location</b><span id="kvLoc">—</span></div>
          </div>
          <div
            class="grid cols-auto"
            id="latestChannels"
            style="margin-top: 8px"
          ></div>
          <div class="grid cols-4" style="margin-top: 8px">
            <div class="kv"><b>Flow</b><span id="kvFLO">—</span></div>
            <div class="kv"><b>Checksum</b><span id="kvCS">—</span></div>
          </div>
        </div>

        <!-- Graphs tab -->
        <div id="tab-graphs" hidden>
          <div
            style="
              display: flex;
              gap: 12px;
              flex-wrap: wrap;
              align-items: stretch;
              margin-bottom: 8px;
            "
          >
            <button id="btnPause">Pause</button>
            <label
              ><input type="checkbox" id="chkRolling" /> Rolling avg (5)</label
            >
            <label
              ><input type="checkbox" id="chkAutoY" checked /> Auto
              Y-axis</label
            >
          </div>

          <div class="row wrap">
            <div class="card" style="min-width: 300px">
              <div class="chart-box"><canvas id="chartCounts"></canvas></div>
            </div>
            <div class="card" style="min-width: 300px">
              <div class="chart-box"><canvas id="chartFLO"></canvas></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /*************** Helpers & UI ***************/
      // Put these near the top of the <script> where your other constants live
      const AXIS_COLOR = "#9fb0d0"; // matches your muted text
      const GRID_COLOR = "#223055"; // matches your --line

      const $ = (s) => document.querySelector(s);
      const $$ = (s) => document.querySelectorAll(s);
      const logEl = $("#terminal");
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
      function log(msg, dir = "sys") {
        const ts = new Date().toLocaleTimeString();
        const arrow = dir === "tx" ? "→" : dir === "rx" ? "←" : "*";
        logEl.textContent += `[${ts}] ${arrow} ${msg}\n`;
        logEl.scrollTop = logEl.scrollHeight;
      }
      function setMode(m) {
        $("#mode").textContent = m;
        $("#modeText").textContent = m;
        const d = $("#modeDot");
        d.className = "status-dot";
        if (m === "Counting") d.classList.add("run");
        if (m === "Stopped") d.classList.add("stop");
        deviceMode = m;
      }
      function setModel(s) {
        $("#model").textContent = s || "—";
      }
      function updateUi() {
        const connected = !!port;

        // Baseline enables for the remaining controls
        //$("#btnPollOnce").disabled = !connected || !universalOK;
        $("#btnStandby").disabled = !connected || !universalOK;
        $("#btnClearDevice").disabled = !connected || !universalOK;
        //$("#btnPickFile").disabled = !connected;
        $("#btnExportNow").disabled = !connected;
        $("#btnClearLocal").disabled = !connected;
        //$("#btnAutoSaveEnable").disabled = !connected;

        // Start Counting button: enabled after connect, disabled once counting
        const startBtn = $("#btnStartCounting");
        const standbyBtn = $("#btnStandby");

        startBtn.disabled = !connected || deviceMode === "Counting";
        standbyBtn.disabled = !connected || !universalOK;

        // Highlights
        startBtn.classList.remove("emphasis-green");
        standbyBtn.classList.remove("emphasis-red");

        // After connect & NOT counting → guide user to Start
        if (
          (connected && deviceMode === "Stopped") ||
          deviceMode === "Idle" ||
          deviceMode === "Holding"
        ) {
          startBtn.classList.add("emphasis-green");
          startBtn.disabled = false;
          standbyBtn.classList.remove("emphasis-red");
          standbyBtn.disabled = true;
        }

        console.log(
          `Connected: ${connected}, Universal: ${universalOK}, Device Mode: ${deviceMode}`
        );
        // While counting → guide user to Standby
        if (connected && universalOK && deviceMode === "Counting") {
          standbyBtn.classList.add("emphasis-red");
          startBtn.classList.remove("emphasis-green");
          startBtn.disabled = true;
        }
      }

      /*************** Serial state ***************/
      let port, writer;
      let universalOK = false;
      let autoTimer = null;
      let modeTimer = null;
      let ioBusy = false;
      let deviceMode = "Idle"; // 'Idle' | 'Counting' | 'Holding' | 'Stopped'

      async function writeChar(ch) {
        if (!writer) return;
        await writer.write(new Uint8Array([ch.charCodeAt(0)]));
        log("'" + ch + "'", "tx");
      }
      async function readLine({ timeoutMs = 2500, drainMs = 100 } = {}) {
        if (!port) return "";
        const reader = port.readable.getReader();
        const td = new TextDecoder();
        let text = "";
        let timer;
        try {
          timer = setTimeout(() => {
            try {
              reader.cancel();
            } catch {}
          }, timeoutMs);
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) {
              text += td.decode(value, { stream: true });
              if (/\r|\n/.test(text)) {
                await sleep(drainMs);
                const tail = await reader.read();
                if (tail && tail.value)
                  text += td.decode(tail.value, { stream: true });
                break;
              }
            }
          }
        } catch (_) {
        } finally {
          clearTimeout(timer);
          reader.releaseLock();
        }
        const out = (text || "").trim();
        if (out) log(JSON.stringify(out), "rx");
        return out;
      }
      async function readChar({ timeoutMs = 800 } = {}) {
        if (!port) return "";
        const reader = port.readable.getReader();
        const td = new TextDecoder();
        let out = "";
        let timer;
        try {
          timer = setTimeout(() => {
            try {
              reader.cancel();
            } catch {}
          }, timeoutMs);
          const { value } = await reader.read();
          if (value) out = td.decode(value).trim();
        } catch (_) {
        } finally {
          clearTimeout(timer);
          reader.releaseLock();
        }
        if (out) log(JSON.stringify(out), "rx");
        return out;
      }

      /*************** CSV export & auto‑save ***************/
      let fileHandle = null,
        autosave = false,
        autosaveTimer = null;
      let sampleIndex = 0;
      const buffer = [];
      const pendingLines = [];
      const channelOrder = [];
      function _isDigits(str) {
        if (typeof str !== "string" || !str.length) return false;
        for (let i = 0; i < str.length; i++) {
          const c = str.charCodeAt(i);
          if (c < 48 || c > 57) return false;
        }
        return true;
      }
      function isValidSizeLabel(sz) {
        if (typeof sz !== "string") return false;
        const parts = sz.split(".");
        if (parts.length > 2) return false;
        if (!_isDigits(parts[0])) return false;
        if (parts.length === 2 && (!_isDigits(parts[1]) || parts[1].length > 2))
          return false;
        const v = parseFloat(sz);
        return isFinite(v) && v > 0 && v <= 1000;
      }
      function sanitizeChannels(ch) {
        const out = {};
        if (!ch) return out;
        for (const k in ch) {
          if (!Object.prototype.hasOwnProperty.call(ch, k)) continue;
          const v = ch[k];
          if (!isValidSizeLabel(k)) continue;
          const n = Number(v);
          if (!Number.isFinite(n) || n < 0) continue;
          out[k] = Math.trunc(n);
        }
        return out;
      }
      function fmtDate(s) {
        if (typeof s === "string" && s.length === 6 && _isDigits(s)) {
          const mm = s.slice(0, 2),
            dd = s.slice(2, 4),
            yy = s.slice(4, 6);
          return dd + "/" + mm + "/" + yy;
        }
        return s || "";
      }
      function fmtTime(s) {
        if (typeof s === "string" && s.length === 6 && _isDigits(s)) {
          const hh = s.slice(0, 2),
            mi = s.slice(2, 4),
            ss = s.slice(4, 6);
          return hh + ":" + mi + ":" + ss;
        }
        return s || "";
      }
      function headerRow() {
        const base = ["ISO_TS", "SampleIndex", "Date", "Time", "Period"];
        const chanCols = channelOrder.map(function (sz) {
          return "Ch " + sz;
        });
        const tail = ["Flow", "Location", "Checksum"];
        return base.concat(chanCols).concat(tail);
      }
      function csvEscape(s) {
        if (s == null) return "";
        const t = String(s);
        return /[",\n]/.test(t) ? '"' + t.replace(/"/g, '""') + '"' : t;
      }
      function toCSV(rows) {
        return rows
          .map(function (r) {
            return r.map(csvEscape).join(",");
          })
          .join("\n");
      }
      function setSaveHint(msg) {
        $("#saveHint").textContent = msg;
      }
      async function pickFile() {
        if (!window.showSaveFilePicker) {
          setSaveHint("File System Access API not supported");
          return;
        }
        try {
          fileHandle = await window.showSaveFilePicker({
            suggestedName: "metone_records.csv",
            types: [{ description: "CSV", accept: { "text/csv": [".csv"] } }],
          });
          const w = await fileHandle.createWritable();
          await w.write(toCSV([headerRow()]) + "\n");
          await w.close();
          setSaveHint("Chosen: " + (fileHandle.name || "metone_records.csv"));
        } catch (e) {
          setSaveHint("No file chosen");
        }
      }
      async function flushAutosave() {
        if (!autosave || !fileHandle || pendingLines.length === 0) return;
        try {
          const w = await fileHandle.createWritable({ keepExistingData: true });
          const f = await fileHandle.getFile();
          await w.seek(f.size);
          await w.write(toCSV(pendingLines) + "\n");
          await w.close();
          pendingLines.length = 0;
        } catch (e) {
          log("Auto‑save error: " + e);
        }
      }

      function downloadCSVNow() {
        if (buffer.length === 0) {
          log("No buffered records to export");
          return;
        }
        const rows = [headerRow()].concat(
          buffer.map(recordToRow).filter(function (r) {
            return Array.isArray(r);
          })
        );
        const csv = toCSV(rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const ts = new Date().toISOString().replace(/[:T]/g, "-").slice(0, 19);
        a.href = url;
        a.download = "metone_3315_records_" + ts + ".csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log("CSV exported");
      }
      function clearLocal() {
        buffer.length = 0;
        sampleIndex = 0;
        pendingLines.length = 0;
        log("Cleared local buffer");
      }

      /*************** Tabs & Charts ***************/

      // Handle tab switching: clicking a tab button marks it active
      // and shows the corresponding panel while hiding the others.
      $$(".tabs button").forEach(function (btn) {
        btn.addEventListener("click", function () {
          $$(".tabs button").forEach(function (b) {
            b.classList.remove("active");
          });
          btn.classList.add("active");
          // Show/hide tab bodies to match the clicked tab
          $("#tab-raw").hidden = btn.dataset.tab !== "raw";
          $("#tab-latest").hidden = btn.dataset.tab !== "latest";
          $("#tab-graphs").hidden = btn.dataset.tab !== "graphs";
        });
      });

      // Shared x-axis labels (timestamps or HH:MM:SS strings)
      const labels = [];

      // Map from channel size string (e.g., "0.3", "10") -> array of y-values.
      // Each array aligns 1:1 with the 'labels' array.
      const seriesMap = new Map();

      // Separate array for Flow line chart (also aligns with 'labels')
      const floData = [];

      // When true, we skip chartCounts.update()/chartFLO.update()
      // (data still accrues; we just don't redraw)
      let paused = false;

      // Main counts chart (multiple datasets; one per channel size)

      const chartCounts = new Chart($("#chartCounts"), {
        type: "line",
        data: { labels, datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          elements: { point: { radius: 2 } },
          scales: {
            x: { ticks: { color: AXIS_COLOR }, grid: { color: GRID_COLOR } },
            y: {
              beginAtZero: $("#chkAutoY").checked,
              suggestedMax: 1, // ensures non-flat scale even when all zeros
              ticks: { color: AXIS_COLOR },
              grid: { color: GRID_COLOR },
            },
          },
          plugins: { legend: { labels: { color: AXIS_COLOR } } },
        },
      });

      const chartFLO = new Chart($("#chartFLO"), {
        type: "line",
        data: { labels, datasets: [{ label: "Flow", data: floData }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          elements: { point: { radius: 2 } },
          scales: {
            x: { ticks: { color: AXIS_COLOR }, grid: { color: GRID_COLOR } },
            y: {
              beginAtZero: $("#chkAutoY").checked,
              suggestedMax: 1,
              ticks: { color: AXIS_COLOR },
              grid: { color: GRID_COLOR },
            },
          },
          plugins: { legend: { labels: { color: AXIS_COLOR } } },
        },
      });

      // Pause/resume drawing (data still collected while paused)
      $("#btnPause").onclick = function () {
        paused = !paused;
        $("#btnPause").textContent = paused ? "Resume" : "Pause";
      };

      // Toggle beginAtZero on both charts’ y-axes and redraw them
      $("#chkAutoY").onchange = function () {
        [chartCounts, chartFLO].forEach(function (c) {
          c.options.scales.y.beginAtZero = $("#chkAutoY").checked;
          c.update("none"); // 'none' = no animation for snappier UI
        });
      };

      $$(".tabs button").forEach(function (btn) {
        btn.addEventListener("click", function () {
          $$(".tabs button").forEach(function (b) {
            b.classList.remove("active");
          });
          btn.classList.add("active");

          $("#tab-raw").hidden = btn.dataset.tab !== "raw";
          $("#tab-latest").hidden = btn.dataset.tab !== "latest";
          $("#tab-graphs").hidden = btn.dataset.tab !== "graphs";

          if (btn.dataset.tab === "graphs") {
            // Let the browser lay out the now-visible elements, then force chart resize
            requestAnimationFrame(() => {
              console.log("graphs tab shown → resizing charts");
              chartCounts.resize();
              chartFLO.resize();
              chartCounts.update("none");
              chartFLO.update("none");
            });
          }
        });
      });

      // Ensure a dataset exists for a given channel size. If it's new,
      // create an empty array, store it in seriesMap, and register a dataset
      // in the counts chart pointing at that array.
      function ensureDataset(sizeLabel) {
        if (seriesMap.has(sizeLabel)) {
          console.debug(
            "ensureDataset exists:",
            sizeLabel,
            "len:",
            seriesMap.get(sizeLabel).length
          );
          return seriesMap.get(sizeLabel);
        }
        // Backfill to current label count so it’s aligned immediately
        const arr = new Array(labels.length).fill(0);
        seriesMap.set(sizeLabel, arr);
        chartCounts.data.datasets.push({ label: sizeLabel + " µm", data: arr });
        console.debug(
          "ensureDataset NEW:",
          sizeLabel,
          "init len:",
          arr.length,
          "labels len:",
          labels.length
        );
        return arr;
      }

      // Accepts either an object map { "0.3": 123, ... } or an array
      // [{size:"0.3", count:123}, ...] and returns a normalized object map.
      // This lets upstream parsing change shape without breaking chart code.
      function channelsToObject(chArrOrObj) {
        if (!chArrOrObj) return {};
        if (Array.isArray(chArrOrObj)) {
          const o = {};
          chArrOrObj.forEach(({ size, count }) => {
            if (size != null) {
              const key = String(size).replace(/\.$/, ""); // normalize "10." -> "10"
              o[key] = Number(count) || 0;
            }
          });
          return o;
        }
        return chArrOrObj; // already an object map
      }

      // Push one numeric point into the series array for the current timestep.
      // Trims older points when >300 for a rolling window.
      // If "Rolling avg" is checked, it replaces the latest point with a small average.
      function pushPoint(arr, val) {
        const before = arr.length;
        arr.push(Number(val || 0));
        if (arr.length > 300) arr.shift(); // keep window small to avoid heavy charts
        console.debug("pushPoint", { before, after: arr.length, val: val });

        if ($("#chkRolling").checked) {
          const n = Math.min(5, arr.length);
          const avg = arr.slice(-n).reduce((a, b) => a + b, 0) / n;
          arr[arr.length - 1] = avg;
          console.debug("pushPoint rolling avg applied:", { n, avg });
        }
      }

      // MAIN ENTRY for each parsed record arriving from the device.
      // Adds a new label (time), pads all existing series with 0 for this tick,
      // sets actual values for any channels present in this record,
      // appends Flow, then refreshes the charts (unless paused).
      function pushSeries(parsed) {
        console.group("pushSeries");
        console.debug("incoming parsed:", parsed);

        // 1) Advance the shared x-axis with this record's time (or "now")
        const t = parsed.time || new Date().toLocaleTimeString();
        labels.push(t);
        if (labels.length > 300) labels.shift(); // same window as y-series

        // 2) For every channel we’ve already seen, assume 0 at this tick,
        //    so the line continues even if the channel didn't show up this record.
        seriesMap.forEach((arr, label) => {
          pushPoint(arr, 0);
          console.debug("default 0 appended to", label, "len:", arr.length);
        });

        // 3) Set real values for the channels that ARE present in this record
        //    (this will create new datasets on the fly if we see a new channel).
        // Normalize channel shape (array -> object map)
        const channels = channelsToObject(parsed.channels);
        console.debug(
          "normalized channels:",
          channels,
          "labels len:",
          labels.length
        );

        Object.keys(channels).forEach((sz) => {
          const arr = ensureDataset(sz);

          // If this dataset somehow isn't caught up, pad it to match labels
          if (arr.length < labels.length) {
            const missing = labels.length - arr.length;
            console.debug("pad dataset", sz, "by", missing, "to match labels");
            for (let i = 0; i < missing; i++) arr.push(0);
          }

          // Overwrite current-tick value
          arr[arr.length - 1] = Number(channels[sz] || 0);
          console.debug(
            "set latest value",
            sz,
            "->",
            arr[arr.length - 1],
            "len:",
            arr.length
          );

          // Optional per-series rolling average (last point only)
          if ($("#chkRolling").checked) {
            const n = Math.min(5, arr.length);
            const avg = arr.slice(-n).reduce((a, b) => a + b, 0) / n;
            arr[arr.length - 1] = avg;
            console.debug("rolling avg applied", sz, "n=", n, "avg=", avg);
          }
        });

        // 4) Flow chart: push this record's flow value at the same tick
        pushPoint(floData, parsed.flow || 0);
        console.debug(
          "floData len:",
          floData.length,
          "last:",
          floData[floData.length - 1]
        );

        console.debug(
          "labels len:",
          labels.length,
          "labels[last]:",
          labels[labels.length - 1]
        );

        // 5) Redraw (unless paused). Both charts share the same labels array,
        //    so the x-axis advances in sync.
        if (!paused) {
          console.debug(
            "updating charts…",
            "counts datasets:",
            chartCounts.data.datasets.map((d) => ({
              label: d.label,
              len: d.data.length,
            })),
            "flo len:",
            floData.length
          );
          console.debug(
            "about to update charts: labels=",
            labels.length,
            "counts datasets:",
            chartCounts.data.datasets.map((d) => ({
              label: d.label,
              len: d.data.length,
            })),
            "flo len:",
            floData.length
          );
          chartCounts.update("none");
          chartFLO.update("none");
        } else {
          console.debug("charts paused – no update call");
        }

        console.groupEnd();
      }

      /*************** Protocol ***************/
      async function connect() {
        try {
          port = await navigator.serial.requestPort({});
          await port.open({
            baudRate: 9600,
            dataBits: 8,
            stopBits: 1,
            parity: "none",
            bufferSize: 8192,
          });
          writer = port.writable.getWriter();
          $("#portName").textContent = port.getInfo().usbProductId
            ? `USB PID ${port.getInfo().usbProductId}`
            : "Serial Port";
          log("Connected");
          $("#btnDisconnect").disabled = false;
          $("#btnConnect").disabled = true;
          updateUi();
        } catch (e) {
          log("Connect error: " + e);
        }
      }
      async function disconnect() {
        stopAuto();
        stopModePolling();
        try {
          if (writer) {
            writer.releaseLock();
            writer = null;
          }
        } catch (e) {}
        try {
          if (port) {
            await port.close();
            port = null;
          }
        } catch (e) {}
        universalOK = false;
        setMode("Idle");
        $("#btnDisconnect").disabled = true;
        $("#btnConnect").disabled = false;
        updateUi();
        log("Disconnected");
      }

      // Combined action: enter universal mode (if needed) then start auto counting
      async function startCounting() {
        if (!port) {
          log("No port connected.");
          return;
        }

        // If not in universal mode yet, enter it
        if (!universalOK) {
          log("Attempting Universal mode…");
          const ok = await enterUniversal(); // already sets universalOK & starts mode polling
          if (!ok) {
            log("Universal mode failed. Cannot start counting.");
            return;
          }
        }

        // Identify the device (set model UI); continue even if this fails
        const idOK = await identify();
        if (!idOK) {
          log("Identify did not return a model; continuing…");
        }

        // Now start auto counting (sends 'a' then 'd' and starts polling loop)
        await autoCommand();
        log("Counting started (auto).");
        updateUi();
      }

      async function enterUniversal() {
        if (!port) return;
        for (let i = 0; i < 10; i++) {
          await writeChar("U");
          await sleep(200);
          const resp = await readChar({ timeoutMs: 600 });
          if ((resp || "").toUpperCase().indexOf("U") !== -1) {
            log("Universal mode acknowledged");
            universalOK = true;
            updateUi();
            startModePolling();
            return true;
          }
          log("No response, retrying…");
          await sleep(800);
        }
        log("Universal mode failed");
        return false;
      }
      async function identify() {
        if (!universalOK) return false;
        await writeChar("T");
        const s = await readLine({ timeoutMs: 1500 });
        if (s) {
          // Example responses: "3315", "2400", etc — take first token
          const mdl = s.trim().split(/\s+/)[0];
          setModel(mdl);
          log("Identified model: " + mdl);
          return true;
        }
        log("Identify returned no data.");
        return false;
      }

      function startAuto() {
        if (!universalOK) return;
        stopAuto();
        autoTimer = setInterval(requestRecord, 1000);
        setMode("Counting");
      }
      function stopAuto() {
        if (autoTimer) clearInterval(autoTimer);
        autoTimer = null;
      }
      async function autoCommand() {
        if (!universalOK) return;
        await writeChar("a");
        await sleep(50);
        await writeChar("d");
        startAuto();
      }
      async function standby() {
        if (!universalOK) return;
        await writeChar("h");
        setMode("Stopped");
        stopAuto();
        updateUi();
      }
      async function clearDeviceBuffer() {
        if (!universalOK) return;
        await writeChar("C");
        log("Requested device buffer clear (C).");
      }
      async function pollOnce() {
        if (!universalOK) return;
        await requestRecord();
      }

      // Mode polling
      async function pollMode() {
        if (!universalOK || ioBusy) return;
        ioBusy = true;
        try {
          await writeChar("M");
          const r = await readChar({ timeoutMs: 300 });
          const c = (r || "").trim().toUpperCase();
          if (c.indexOf("C") === 0) setMode("Counting");
          else if (c.indexOf("H") === 0) setMode("Holding");
          else if (c.indexOf("S") === 0) setMode("Stopped");
          updateUi();
        } catch (e) {
        } finally {
          ioBusy = false;
        }
      }
      function startModePolling() {
        stopModePolling();
        modeTimer = setInterval(pollMode, 1500);
      }
      function stopModePolling() {
        if (modeTimer) clearInterval(modeTimer);
        modeTimer = null;
      }

      /*************** Parsing & record loop (with DEBUG) ***************/
      const TAGS = new Set(["A/V", "FLO", "LOC", "C/S"]);

      // Reorder global CSV/Latest channel columns to match the most recent record,
      // while keeping previously-seen-but-missing-this-time sizes at the end.
      function updateChannelOrderFromRecord(order) {
        if (!Array.isArray(order) || order.length === 0) return;
        const seen = new Set(order);
        const remainder = channelOrder.filter((sz) => !seen.has(sz));
        channelOrder.length = 0;
        order.forEach((sz) => {
          if (!channelOrder.includes(sz)) channelOrder.push(sz);
        });
        remainder.forEach((sz) => channelOrder.push(sz));
      }

      function looksLikeSize(tok) {
        // Channels always include a decimal; allow trailing dot (e.g., "10.")
        return /^\d+\.\d*$/.test(tok);
      }

      function parseRecord(s) {
        console.log("parseRecord");
        console.log("raw line:", s);
        try {
          let text = (s || "").trim();
          text = text.replace(/^A[\s`]+/, "");
          text = text.replace(/^\$\s*/, "");
          text = text.replace(/\s+/g, " ").trim();

          let parts = text.split(" ");
          // Remove tokens with '#' or non-digit chars if in first 2 tokens
          parts = parts.filter((tok, idx) => {
            if (idx < 2) {
              if (tok.includes("#")) return false;
              if (/[^0-9]/.test(tok)) return false;
            }
            return true;
          });
          console.log("tokens:", parts);
          if (parts.length < 3) {
            console.log("too few tokens");
            return null;
          }

          const out = {
            date: parts[0],
            time: parts[1],
            period: parts[2],
            channels: {},
            air_velocity: null,
            flow: null,
            location: null,
            checksum: null,
            raw: text,
            channelOrder: [], // ← NEW: preserve encounter order
          };

          let i = 3;
          while (i + 1 < parts.length) {
            const tok = parts[i];
            if (TAGS.has(tok)) break;
            if (!looksLikeSize(tok)) {
              console.log("stop channels at token", tok);
              break;
            }

            const size = tok.replace(/\.$/, ""); // allow "10." -> "10"
            const cntTok = parts[i + 1];
            const cnt = parseInt((cntTok || "").replace(/[^0-9]/g, ""));

            console.log("channel pair candidate:", { size, cntTok, cnt });
            if (Number.isFinite(cnt)) {
              out.channels[size] = cnt;
              out.channelOrder.push(size); // ← NEW: remember order
            } else {
              console.warn("bad count token, skipping", cntTok);
            }
            i += 2;
          }

          while (i + 1 < parts.length) {
            const tag = parts[i],
              val = parts[i + 1];
            console.log("tag pair:", tag, val);
            if (tag === "A/V") out.air_velocity = parseInt(val) || 0;
            else if (tag === "FLO") out.flow = parseInt(val) || 0;
            else if (tag === "LOC") out.location = parseInt(val) || 0;
            else if (tag === "C/S") out.checksum = val;
            i += 2;
          }

          console.log("parsed object:", out);
          return out;
        } catch (e) {
          console.log("parse error:", e);
          log("Parse error: " + e);
          return null;
        }
      }

      function renderLatest(p) {
        $("#kvDate").textContent = fmtDate(p.date);
        $("#kvTime").textContent = fmtTime(p.time);
        $("#kvPeriod").textContent = p.period || "—";
        $("#kvLoc").textContent = p.location != null ? p.location : "—";
        $("#kvFLO").textContent = p.flow != null ? p.flow : "—";
        $("#kvCS").textContent = p.checksum != null ? p.checksum : "—";

        const host = $("#latestChannels");
        host.innerHTML = "";

        const channels = channelsToObject(p.channels);
        Object.keys(channels).forEach((sz) => {
          const div = document.createElement("div");
          div.className = "kv";
          div.innerHTML = `<b>${sz} µm</b><span>${channels[sz]}</span>`;
          host.appendChild(div);
        });
      }

      function recordToRow(r) {
        console.group("recordToRow");
        console.debug("raw record obj:", r);

        const cleanChannels = sanitizeChannels(channelsToObject(r.channels));
        console.debug("sanitized channels:", cleanChannels);

        Object.keys(cleanChannels).forEach((sz) => {
          if (channelOrder.indexOf(sz) === -1) channelOrder.push(sz);
        });

        const dateOk =
          !r.date ||
          (typeof r.date === "string" &&
            r.date.length === 6 &&
            _isDigits(r.date));
        const timeOk =
          !r.time ||
          (typeof r.time === "string" &&
            r.time.length === 6 &&
            _isDigits(r.time));
        const hasAnyChannel = Object.keys(cleanChannels).length > 0;

        if (!hasAnyChannel && !(dateOk && timeOk)) {
          console.warn("drop row – no valid channels & bad date/time", r);
          console.groupEnd();
          return null;
        }

        const iso = new Date().toISOString();
        const row = [
          iso,
          sampleIndex,
          fmtDate(r.date),
          fmtTime(r.time),
          r.period || "",
        ];
        channelOrder.forEach((sz) =>
          row.push(
            Object.prototype.hasOwnProperty.call(cleanChannels, sz)
              ? cleanChannels[sz]
              : ""
          )
        );
        row.push(
          r.flow != null ? r.flow : "",
          r.location != null ? r.location : "",
          r.checksum != null ? r.checksum : ""
        );
        console.debug("final csv row:", row);
        console.groupEnd();
        return row;
      }

      async function requestRecord() {
        if (ioBusy) return;
        ioBusy = true;
        try {
          await writeChar("A");
          const line = await readLine({ timeoutMs: 2500, drainMs: 100 });
          if (!line) return;
          const t = line.trim();
          if (/^A#/.test(t)) return;
          let rec = t;
          rec = rec.replace(/^A[\s`]*/, "");
          rec = rec.replace(/^\$\s*/, "");
          log("Record: " + rec);
          const parsed = parseRecord(rec);
          if (!parsed) {
            log("Record parse failed");
            return;
          }
          renderLatest(parsed);
          console.log("sending to graphing:", {
            time: parsed.time,
            flow: parsed.flow,
            channels: channelsToObject(parsed.channels),
          });
          pushSeries(parsed);
          const row = recordToRow({
            index: sampleIndex,
            date: parsed.date,
            time: parsed.time,
            period: parsed.period,
            channels: parsed.channels,
            channelOrder: parsed.channelOrder, // ← NEW
            flow: parsed.flow,
            location: parsed.location,
            checksum: parsed.checksum,
          });
          if (Array.isArray(row)) {
            sampleIndex++;
            buffer.push(parsed);
            pendingLines.push(row);
          }
        } finally {
          ioBusy = false;
        }
      }

      /*************** Wire UI ***************/
      $("#btnConnect").onclick = connect;
      $("#btnDisconnect").onclick = disconnect;
      $("#btnStartCounting").onclick = startCounting;
      //$("#btnEnterUniversal").onclick = enterUniversal;
      //$("#btnIdentify").onclick = identify;
      //$("#btnAuto").onclick = autoCommand;
      //$("#btnPollOnce").onclick = pollOnce;
      $("#btnStandby").onclick = standby;
      $("#btnClearDevice").onclick = clearDeviceBuffer;
      //$("#btnPickFile").onclick = pickFile;
      //$("#btnAutoSaveEnable").onclick = enableAutosave;
      //$("#btnAutoSaveDisable").onclick = disableAutosave;
      $("#btnExportNow").onclick = downloadCSVNow;
      $("#btnClearLocal").onclick = clearLocal;

      // Capability check
      if (!("serial" in navigator)) {
        log(
          "WebSerial not supported in this browser. Use a recent Chrome/Edge."
        );
        $("#btnConnect").disabled = true;
      }
    </script>
  </body>
</html>
